heat_template_version: queens

parameters:
  name:
    type: string
    label: name
    default: name
  image:
    type: string
    label: Image ID
    description: Image to be used
    default: d9af69c3-ba98-4348-b59b-dc6cacce3d7d
  key_name:
    type: string
    label: Key Name
    description: SSH key to be used for all instances
    default: admin
  flavor:
    type: string
    label: Instance Type
    description: Type of instance (flavor) to deploy
    default: m1.small
  fixed_network:
    type: string
    default: private
  fixed_subnet:
    type: string
    default: private-subnet
  pods_network_cidr:
    type: string
    default: 10.254.0.0/16
  role:
    type: string
  etcd_volume_size:
    type: number
    default: 0
  etcd_volume_type:
    type: string
    default: ""
  docker_volume_size:
    type: number
    default: 0
  docker_volume_type:
    type: string
    default: ""
  secgroup:
    type: string
  master_lb_enabled:
    type: boolean
  floating_ip_enabled:
    type: boolean
  external_network:
    type: string
    description: uuid/name of a network to use for floating ip addresses
    default: public
  api_pool_id:
    type: string
    description: ID of the load balancer pool of k8s API server.
    default: ""
  node_software_configs:
    type: string
  node_common_deployment:
    type: string
  octavia_enabled:
    type: boolean

resources:

  node:
    type: OS::Nova::Server
    properties:
      key_name: { get_param: key_name }
      image: { get_param: image }
      flavor: { get_param: flavor }
      name: { get_param: name }
      user_data_format: SOFTWARE_CONFIG
      software_config_transport: POLL_SERVER_HEAT
      user_data: {get_param: node_software_configs}
      networks:
        - port: {get_resource: node_eth0}

  node_eth0:
    type: OS::Neutron::Port
    properties:
      network: {get_param: fixed_network}
      security_groups:
        - get_param: secgroup
      fixed_ips:
        - subnet: {get_param: fixed_subnet}
      allowed_address_pairs:
        - ip_address: {get_param: pods_network_cidr}
      replacement_policy: AUTO

  fip:
    condition: create_fip
    type: OS::Neutron::FloatingIP
    properties:
      port_id: {get_resource: node_eth0}
      floating_network: { get_param: external_network }

  api_pool_member:
    condition: add_member_to_pool
    type: OS::Neutron::LBaaS::PoolMember
    properties:
      pool: { get_param: api_pool_id }
      address: {get_attr: [node_eth0, fixed_ips, 0, ip_address]}
      subnet: { get_param: fixed_subnet }
      protocol_port: 6443

  api_octvia_pool_member:
    condition: add_member_to_octavia_pool
    type: OS::Octavia::PoolMember
    properties:
      pool: { get_param: api_pool_id }
      address: {get_attr: [node_eth0, fixed_ips, 0, ip_address]}
      subnet: { get_param: fixed_subnet }
      protocol_port: 6443
  ######################################################################
  #
  # etcd storage.  This allocates a cinder volume and attaches it
  # to the master.
  #
  etcd_volume:
    condition: create_etcd_volume
    type: OS::Cinder::Volume
    properties:
      size: { get_param: etcd_volume_size }
      volume_type: { get_param: etcd_volume_type }

  etcd_volume_attachment:
    condition: create_etcd_volume
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: node }
      volume_id: {get_resource: etcd_volume}
      mountpoint: /dev/vdc
  ######################################################################
  #
  # docker storage.  This allocates a cinder volume and attaches it
  # to the minion.
  #
  docker_volume:
    condition: create_docker_volume
    type: OS::Cinder::Volume
    properties:
      size: { get_param: docker_volume_size }
      volume_type: { get_param: docker_volume_type }

  docker_volume_attachment:
    condition: create_docker_volume
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: node }
      volume_id: {get_resource: docker_volume}
      mountpoint: /dev/vdb

  node_software_deployment:
    type: OS::Heat::SoftwareDeployment
    properties:
      actions: ['CREATE']
      signal_transport: HEAT_SIGNAL
      config:
        get_param: node_common_deployment
      server:
        get_resource: node

conditions:
  is_master: {equals : [{get_param: role}, "master"]}
  is_worker: {not: {equals : [{get_param: role}, "master"]}}
  create_etcd_volume:
    and:
    - not:
        equals:
        - get_param: etcd_volume_size
        - 0
    - equals:
      - get_param: role
      - master
  create_fip:
    equals:
    - get_param: floating_ip_enabled
    - true
  add_member_to_pool:
    and:
    - equals:
      - get_param: master_lb_enabled
      - true
    - equals:
      - get_param: role
      - master
    - equals:
      - get_param: octavia_enabled
      - false
  add_member_to_octavia_pool:
    and:
    - equals:
      - get_param: master_lb_enabled
      - true
    - equals:
      - get_param: role
      - master
    - equals:
      - get_param: octavia_enabled
      - true
  create_docker_volume: {not: {equals : [{get_param: docker_volume_size}, 0]}}

outputs:

  node_server_id:
    value: { get_resource: node }
    description: >
      The id of the server.

  node_ip:
    value: { if: ["create_fip", {get_attr: [fip, floating_ip_address]},  {get_attr: [node_eth0, fixed_ips, 0, ip_address]} ] }
    description: >
      This is the "public" IP address of the Kubernetes master node.

  OS::stack_id:
    value: { get_resource: node }
    description: >
      This is the Nova server id of the node.

  node_id_map:
    value:
      map_replace:
      - name: { get_resource: node }
      - keys: { name: {get_param: name }}
